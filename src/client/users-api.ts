// tslint:disable
/**
 * Invotra API
 * In general most fields are optional for update (PUT) requests; you can leave them blank (pass an empty string / array / whatever as appropriate) to clear them, or omit the key to leave them unchanged.
 *
 * The version of the OpenAPI document: 0.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';

import { CommonStatusSchema } from '../model';
import { InlineResponse2002 } from '../model';
import { InlineResponse2003 } from '../model';
import { InlineResponse2004 } from '../model';
import { InlineResponse2005 } from '../model';
import { InlineResponse2006 } from '../model';
import { InlineResponse2007 } from '../model';
import { InlineResponse2008 } from '../model';
import { SuccessfulPostResponseSchema } from '../model';
import { UserMetricsAccessedSchema } from '../model';
import { UserMetricsProfilesSchema } from '../model';
import { UserSchema } from '../model';
import { UserSchemaCreate } from '../model';
import { UserSchemaUpdate } from '../model';
import { UserSearchSchema } from '../model';
import { UuidListSchema } from '../model';
/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search for users. Returns list of uuids.
         * @param {string} external_id Filter by external ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(external_id: string, options: any = {}): RequestArgs {
            // verify required parameter 'external_id' is not null or undefined
            if (external_id === null || external_id === undefined) {
                throw new RequiredError('external_id','Required parameter external_id was null or undefined when calling usersGet.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required

            if (external_id !== undefined) {
                localVarQueryParameter['external_id'] = external_id;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current user\'s information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options: any = {}): RequestArgs {
            const localVarPath = `/users/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:self:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Autocomplete names and email addresses for @-mentioning. The text parameter matches against the start of the user\'s full name (forename surname or surname forename) or email address. Full user objects are returned. The list may optionally be filtered by group to show only members of the group, to allow completing only users that can be mentioned when composing a group post. You can not filter by members of a private or secret group unless you are a member yourself. Webmasters can always be mentioned, so they are always matched even if they are not members of the group being filtered. Redacted users are never matched.
         * @summary Autocomplete names and email addresses for @-mentioning.
         * @param {string} text Text to match against the start of the user\&#39;s full name or email address.
         * @param {string} [group] UUID of the group to filter by.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMentionGet(text: string, group?: string, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'text' is not null or undefined
            if (text === null || text === undefined) {
                throw new RequiredError('text','Required parameter text was null or undefined when calling usersMentionGet.');
            }
            const localVarPath = `/users/mention`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a count of users who accessed the site on 4 or more days within a given calendar month.
         * @param {string} month Filter by calendar month. Format: YYYY-MM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMetricsAccessedGet(month: string, options: any = {}): RequestArgs {
            // verify required parameter 'month' is not null or undefined
            if (month === null || month === undefined) {
                throw new RequiredError('month','Required parameter month was null or undefined when calling usersMetricsAccessedGet.');
            }
            const localVarPath = `/users/metrics/accessed`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:admin"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the total count of active users (i.e. not blocked) profiles matching various conditions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMetricsProfilesGet(options: any = {}): RequestArgs {
            const localVarPath = `/users/metrics/profiles`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:admin"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provision a new user in Invotra.
         * @param {UserSchemaCreate} UserSchemaCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(UserSchemaCreate: UserSchemaCreate, options: any = {}): RequestArgs {
            // verify required parameter 'UserSchemaCreate' is not null or undefined
            if (UserSchemaCreate === null || UserSchemaCreate === undefined) {
                throw new RequiredError('UserSchemaCreate','Required parameter UserSchemaCreate was null or undefined when calling usersPost.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof UserSchemaCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(UserSchemaCreate !== undefined ? UserSchemaCreate : {}) : (UserSchemaCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for users. Returns user snippets. If there are no result, an empty array is returned.
         * @param {string} [fulltext_search] Search term. Matches on whole words.
         * @param {string} [team] The Invotra UUID of the team to filter by.
         * @param {string} [location] The Invotra UUID of the location to filter by.
         * @param {string} [group] The Invotra UUID of the group to filter by.
         * @param {'firstname' | 'surname' | 'updated' | 'relevance'} [sort] Field to sort by
         * @param {'asc' | 'desc'} [order] Sort order
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSearchGet(fulltext_search?: string, team?: string, location?: string, group?: string, sort?: 'firstname' | 'surname' | 'updated' | 'relevance', order?: 'asc' | 'desc', offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/users/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required

            if (fulltext_search !== undefined) {
                localVarQueryParameter['fulltext_search'] = fulltext_search;
            }

            if (team !== undefined) {
                localVarQueryParameter['team'] = team;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the user\'s activity feed.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {boolean} [app_feeds_only] Filter the feed for the mobile app. Returns only group related messages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdActivityGet(user_id: string, offset?: number, limit?: number, app_feeds_only?: boolean, options: any = {}): RequestArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdActivityGet.');
            }
            const localVarPath = `/users/{user_id}/activity`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (app_feeds_only !== undefined) {
                localVarQueryParameter['app_feeds_only'] = app_feeds_only;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop following a user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowDelete(user_id: string, options: any = {}): RequestArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdFollowDelete.');
            }
            const localVarPath = `/users/{user_id}/follow`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} user_id The Invotra UUID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowGet(user_id: string, options: any = {}): RequestArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdFollowGet.');
            }
            const localVarPath = `/users/{user_id}/follow`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Follow a user as another user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowPut(user_id: string, options: any = {}): RequestArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdFollowPut.');
            }
            const localVarPath = `/users/{user_id}/follow`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of who a user is following.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowingGet(user_id: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdFollowingGet.');
            }
            const localVarPath = `/users/{user_id}/following`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user\'s information.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGet(user_id: string, options: any = {}): RequestArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdGet.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List a user\'s groups.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGroupsGet(user_id: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdGroupsGet.');
            }
            const localVarPath = `/users/{user_id}/groups`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:read", "invotra/groups:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the user\'s job roles.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdJobRolesGet(user_id: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdJobRolesGet.');
            }
            const localVarPath = `/users/{user_id}/job_roles`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:read", "invotra/job_roles:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a job role from a user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {string} job_role_id The Invotra UUID of the job role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdJobRolesJobRoleIdDelete(user_id: string, job_role_id: string, options: any = {}): RequestArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdJobRolesJobRoleIdDelete.');
            }
            // verify required parameter 'job_role_id' is not null or undefined
            if (job_role_id === null || job_role_id === undefined) {
                throw new RequiredError('job_role_id','Required parameter job_role_id was null or undefined when calling usersUserIdJobRolesJobRoleIdDelete.');
            }
            const localVarPath = `/users/{user_id}/job_roles/{job_role_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"job_role_id"}}`, encodeURIComponent(String(job_role_id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:write", "invotra/job_roles:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a job role to a user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {string} job_role_id The Invotra UUID of the job role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdJobRolesJobRoleIdPut(user_id: string, job_role_id: string, options: any = {}): RequestArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdJobRolesJobRoleIdPut.');
            }
            // verify required parameter 'job_role_id' is not null or undefined
            if (job_role_id === null || job_role_id === undefined) {
                throw new RequiredError('job_role_id','Required parameter job_role_id was null or undefined when calling usersUserIdJobRolesJobRoleIdPut.');
            }
            const localVarPath = `/users/{user_id}/job_roles/{job_role_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"job_role_id"}}`, encodeURIComponent(String(job_role_id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:write", "invotra/job_roles:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the user\'s locations.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLocationsGet(user_id: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdLocationsGet.');
            }
            const localVarPath = `/users/{user_id}/locations`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:read", "invotra/locations:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a location from a user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {string} location_id The Invotra UUID of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLocationsLocationIdDelete(user_id: string, location_id: string, options: any = {}): RequestArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdLocationsLocationIdDelete.');
            }
            // verify required parameter 'location_id' is not null or undefined
            if (location_id === null || location_id === undefined) {
                throw new RequiredError('location_id','Required parameter location_id was null or undefined when calling usersUserIdLocationsLocationIdDelete.');
            }
            const localVarPath = `/users/{user_id}/locations/{location_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"location_id"}}`, encodeURIComponent(String(location_id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:write", "invotra/locations:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a location to a user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {string} location_id The Invotra UUID of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLocationsLocationIdPut(user_id: string, location_id: string, options: any = {}): RequestArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdLocationsLocationIdPut.');
            }
            // verify required parameter 'location_id' is not null or undefined
            if (location_id === null || location_id === undefined) {
                throw new RequiredError('location_id','Required parameter location_id was null or undefined when calling usersUserIdLocationsLocationIdPut.');
            }
            const localVarPath = `/users/{user_id}/locations/{location_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"location_id"}}`, encodeURIComponent(String(location_id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:write", "invotra/locations:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user\'s information.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {UserSchemaUpdate} UserSchemaUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPut(user_id: string, UserSchemaUpdate: UserSchemaUpdate, options: any = {}): RequestArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdPut.');
            }
            // verify required parameter 'UserSchemaUpdate' is not null or undefined
            if (UserSchemaUpdate === null || UserSchemaUpdate === undefined) {
                throw new RequiredError('UserSchemaUpdate','Required parameter UserSchemaUpdate was null or undefined when calling usersUserIdPut.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof UserSchemaUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(UserSchemaUpdate !== undefined ? UserSchemaUpdate : {}) : (UserSchemaUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List a user\'s teams
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTeamsGet(user_id: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdTeamsGet.');
            }
            const localVarPath = `/users/{user_id}/teams`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-Key"] = localVarApiKeyValue;
            }

            // authentication CognitoJwt required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("CognitoJwt", ["invotra/users:read", "invotra/teams:read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication SessionCookieHeader required

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Search for users. Returns list of uuids.
         * @param {string} external_id Filter by external ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(external_id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UuidListSchema> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersGet(external_id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the current user\'s information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchema> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersMeGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Autocomplete names and email addresses for @-mentioning. The text parameter matches against the start of the user\'s full name (forename surname or surname forename) or email address. Full user objects are returned. The list may optionally be filtered by group to show only members of the group, to allow completing only users that can be mentioned when composing a group post. You can not filter by members of a private or secret group unless you are a member yourself. Webmasters can always be mentioned, so they are always matched even if they are not members of the group being filtered. Redacted users are never matched.
         * @summary Autocomplete names and email addresses for @-mentioning.
         * @param {string} text Text to match against the start of the user\&#39;s full name or email address.
         * @param {string} [group] UUID of the group to filter by.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMentionGet(text: string, group?: string, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSearchSchema>> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersMentionGet(text, group, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a count of users who accessed the site on 4 or more days within a given calendar month.
         * @param {string} month Filter by calendar month. Format: YYYY-MM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMetricsAccessedGet(month: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserMetricsAccessedSchema> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersMetricsAccessedGet(month, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the total count of active users (i.e. not blocked) profiles matching various conditions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMetricsProfilesGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserMetricsProfilesSchema> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersMetricsProfilesGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provision a new user in Invotra.
         * @param {UserSchemaCreate} UserSchemaCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(UserSchemaCreate: UserSchemaCreate, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessfulPostResponseSchema> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersPost(UserSchemaCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Search for users. Returns user snippets. If there are no result, an empty array is returned.
         * @param {string} [fulltext_search] Search term. Matches on whole words.
         * @param {string} [team] The Invotra UUID of the team to filter by.
         * @param {string} [location] The Invotra UUID of the location to filter by.
         * @param {string} [group] The Invotra UUID of the group to filter by.
         * @param {'firstname' | 'surname' | 'updated' | 'relevance'} [sort] Field to sort by
         * @param {'asc' | 'desc'} [order] Sort order
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSearchGet(fulltext_search?: string, team?: string, location?: string, group?: string, sort?: 'firstname' | 'surname' | 'updated' | 'relevance', order?: 'asc' | 'desc', offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersSearchGet(fulltext_search, team, location, group, sort, order, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return the user\'s activity feed.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {boolean} [app_feeds_only] Filter the feed for the mobile app. Returns only group related messages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdActivityGet(user_id: string, offset?: number, limit?: number, app_feeds_only?: boolean, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIdActivityGet(user_id, offset, limit, app_feeds_only, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Stop following a user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowDelete(user_id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIdFollowDelete(user_id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} user_id The Invotra UUID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowGet(user_id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonStatusSchema> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIdFollowGet(user_id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Follow a user as another user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowPut(user_id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIdFollowPut(user_id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List of who a user is following.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowingGet(user_id: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIdFollowingGet(user_id, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the user\'s information.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGet(user_id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSchema> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIdGet(user_id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List a user\'s groups.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGroupsGet(user_id: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIdGroupsGet(user_id, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List the user\'s job roles.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdJobRolesGet(user_id: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIdJobRolesGet(user_id, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove a job role from a user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {string} job_role_id The Invotra UUID of the job role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdJobRolesJobRoleIdDelete(user_id: string, job_role_id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIdJobRolesJobRoleIdDelete(user_id, job_role_id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add a job role to a user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {string} job_role_id The Invotra UUID of the job role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdJobRolesJobRoleIdPut(user_id: string, job_role_id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIdJobRolesJobRoleIdPut(user_id, job_role_id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List the user\'s locations.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLocationsGet(user_id: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIdLocationsGet(user_id, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove a location from a user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {string} location_id The Invotra UUID of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLocationsLocationIdDelete(user_id: string, location_id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIdLocationsLocationIdDelete(user_id, location_id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add a location to a user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {string} location_id The Invotra UUID of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLocationsLocationIdPut(user_id: string, location_id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIdLocationsLocationIdPut(user_id, location_id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update the user\'s information.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {UserSchemaUpdate} UserSchemaUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPut(user_id: string, UserSchemaUpdate: UserSchemaUpdate, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIdPut(user_id, UserSchemaUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List a user\'s teams
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTeamsGet(user_id: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersUserIdTeamsGet(user_id, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Search for users. Returns list of uuids.
         * @param {string} external_id Filter by external ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(external_id: string, options?: any): AxiosPromise<UuidListSchema> {
            return UsersApiFp(configuration).usersGet(external_id, options)(axios, basePath);
        },
        /**
         * Get the current user\'s information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options?: any): AxiosPromise<UserSchema> {
            return UsersApiFp(configuration).usersMeGet(options)(axios, basePath);
        },
        /**
         * Autocomplete names and email addresses for @-mentioning. The text parameter matches against the start of the user\'s full name (forename surname or surname forename) or email address. Full user objects are returned. The list may optionally be filtered by group to show only members of the group, to allow completing only users that can be mentioned when composing a group post. You can not filter by members of a private or secret group unless you are a member yourself. Webmasters can always be mentioned, so they are always matched even if they are not members of the group being filtered. Redacted users are never matched.
         * @summary Autocomplete names and email addresses for @-mentioning.
         * @param {string} text Text to match against the start of the user\&#39;s full name or email address.
         * @param {string} [group] UUID of the group to filter by.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMentionGet(text: string, group?: string, limit?: number, options?: any): AxiosPromise<Array<UserSearchSchema>> {
            return UsersApiFp(configuration).usersMentionGet(text, group, limit, options)(axios, basePath);
        },
        /**
         * Returns a count of users who accessed the site on 4 or more days within a given calendar month.
         * @param {string} month Filter by calendar month. Format: YYYY-MM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMetricsAccessedGet(month: string, options?: any): AxiosPromise<UserMetricsAccessedSchema> {
            return UsersApiFp(configuration).usersMetricsAccessedGet(month, options)(axios, basePath);
        },
        /**
         * Returns the total count of active users (i.e. not blocked) profiles matching various conditions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMetricsProfilesGet(options?: any): AxiosPromise<UserMetricsProfilesSchema> {
            return UsersApiFp(configuration).usersMetricsProfilesGet(options)(axios, basePath);
        },
        /**
         * Provision a new user in Invotra.
         * @param {UserSchemaCreate} UserSchemaCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(UserSchemaCreate: UserSchemaCreate, options?: any): AxiosPromise<SuccessfulPostResponseSchema> {
            return UsersApiFp(configuration).usersPost(UserSchemaCreate, options)(axios, basePath);
        },
        /**
         * Search for users. Returns user snippets. If there are no result, an empty array is returned.
         * @param {string} [fulltext_search] Search term. Matches on whole words.
         * @param {string} [team] The Invotra UUID of the team to filter by.
         * @param {string} [location] The Invotra UUID of the location to filter by.
         * @param {string} [group] The Invotra UUID of the group to filter by.
         * @param {'firstname' | 'surname' | 'updated' | 'relevance'} [sort] Field to sort by
         * @param {'asc' | 'desc'} [order] Sort order
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSearchGet(fulltext_search?: string, team?: string, location?: string, group?: string, sort?: 'firstname' | 'surname' | 'updated' | 'relevance', order?: 'asc' | 'desc', offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2002> {
            return UsersApiFp(configuration).usersSearchGet(fulltext_search, team, location, group, sort, order, offset, limit, options)(axios, basePath);
        },
        /**
         * Return the user\'s activity feed.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {boolean} [app_feeds_only] Filter the feed for the mobile app. Returns only group related messages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdActivityGet(user_id: string, offset?: number, limit?: number, app_feeds_only?: boolean, options?: any): AxiosPromise<InlineResponse2003> {
            return UsersApiFp(configuration).usersUserIdActivityGet(user_id, offset, limit, app_feeds_only, options)(axios, basePath);
        },
        /**
         * Stop following a user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowDelete(user_id: string, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).usersUserIdFollowDelete(user_id, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} user_id The Invotra UUID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowGet(user_id: string, options?: any): AxiosPromise<CommonStatusSchema> {
            return UsersApiFp(configuration).usersUserIdFollowGet(user_id, options)(axios, basePath);
        },
        /**
         * Follow a user as another user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowPut(user_id: string, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).usersUserIdFollowPut(user_id, options)(axios, basePath);
        },
        /**
         * List of who a user is following.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdFollowingGet(user_id: string, offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2007> {
            return UsersApiFp(configuration).usersUserIdFollowingGet(user_id, offset, limit, options)(axios, basePath);
        },
        /**
         * Get the user\'s information.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGet(user_id: string, options?: any): AxiosPromise<UserSchema> {
            return UsersApiFp(configuration).usersUserIdGet(user_id, options)(axios, basePath);
        },
        /**
         * List a user\'s groups.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGroupsGet(user_id: string, offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2008> {
            return UsersApiFp(configuration).usersUserIdGroupsGet(user_id, offset, limit, options)(axios, basePath);
        },
        /**
         * List the user\'s job roles.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdJobRolesGet(user_id: string, offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2004> {
            return UsersApiFp(configuration).usersUserIdJobRolesGet(user_id, offset, limit, options)(axios, basePath);
        },
        /**
         * Remove a job role from a user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {string} job_role_id The Invotra UUID of the job role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdJobRolesJobRoleIdDelete(user_id: string, job_role_id: string, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).usersUserIdJobRolesJobRoleIdDelete(user_id, job_role_id, options)(axios, basePath);
        },
        /**
         * Add a job role to a user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {string} job_role_id The Invotra UUID of the job role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdJobRolesJobRoleIdPut(user_id: string, job_role_id: string, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).usersUserIdJobRolesJobRoleIdPut(user_id, job_role_id, options)(axios, basePath);
        },
        /**
         * List the user\'s locations.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLocationsGet(user_id: string, offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2005> {
            return UsersApiFp(configuration).usersUserIdLocationsGet(user_id, offset, limit, options)(axios, basePath);
        },
        /**
         * Remove a location from a user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {string} location_id The Invotra UUID of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLocationsLocationIdDelete(user_id: string, location_id: string, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).usersUserIdLocationsLocationIdDelete(user_id, location_id, options)(axios, basePath);
        },
        /**
         * Add a location to a user.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {string} location_id The Invotra UUID of the location.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLocationsLocationIdPut(user_id: string, location_id: string, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).usersUserIdLocationsLocationIdPut(user_id, location_id, options)(axios, basePath);
        },
        /**
         * Update the user\'s information.
         * @param {string} user_id The Invotra UUID of the user.
         * @param {UserSchemaUpdate} UserSchemaUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPut(user_id: string, UserSchemaUpdate: UserSchemaUpdate, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).usersUserIdPut(user_id, UserSchemaUpdate, options)(axios, basePath);
        },
        /**
         * List a user\'s teams
         * @param {string} user_id The Invotra UUID of the user.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTeamsGet(user_id: string, offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2006> {
            return UsersApiFp(configuration).usersUserIdTeamsGet(user_id, offset, limit, options)(axios, basePath);
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * Search for users. Returns list of uuids.
     * @param {string} external_id Filter by external ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersGet(external_id: string, options?: any): AxiosPromise<UuidListSchema>;

    /**
     * Get the current user\'s information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersMeGet(options?: any): AxiosPromise<UserSchema>;

    /**
     * Autocomplete names and email addresses for @-mentioning. The text parameter matches against the start of the user\'s full name (forename surname or surname forename) or email address. Full user objects are returned. The list may optionally be filtered by group to show only members of the group, to allow completing only users that can be mentioned when composing a group post. You can not filter by members of a private or secret group unless you are a member yourself. Webmasters can always be mentioned, so they are always matched even if they are not members of the group being filtered. Redacted users are never matched.
     * @summary Autocomplete names and email addresses for @-mentioning.
     * @param {string} text Text to match against the start of the user\&#39;s full name or email address.
     * @param {string} [group] UUID of the group to filter by.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersMentionGet(text: string, group?: string, limit?: number, options?: any): AxiosPromise<Array<UserSearchSchema>>;

    /**
     * Returns a count of users who accessed the site on 4 or more days within a given calendar month.
     * @param {string} month Filter by calendar month. Format: YYYY-MM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersMetricsAccessedGet(month: string, options?: any): AxiosPromise<UserMetricsAccessedSchema>;

    /**
     * Returns the total count of active users (i.e. not blocked) profiles matching various conditions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersMetricsProfilesGet(options?: any): AxiosPromise<UserMetricsProfilesSchema>;

    /**
     * Provision a new user in Invotra.
     * @param {UserSchemaCreate} UserSchemaCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersPost(UserSchemaCreate: UserSchemaCreate, options?: any): AxiosPromise<SuccessfulPostResponseSchema>;

    /**
     * Search for users. Returns user snippets. If there are no result, an empty array is returned.
     * @param {string} [fulltext_search] Search term. Matches on whole words.
     * @param {string} [team] The Invotra UUID of the team to filter by.
     * @param {string} [location] The Invotra UUID of the location to filter by.
     * @param {string} [group] The Invotra UUID of the group to filter by.
     * @param {'firstname' | 'surname' | 'updated' | 'relevance'} [sort] Field to sort by
     * @param {'asc' | 'desc'} [order] Sort order
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersSearchGet(fulltext_search?: string, team?: string, location?: string, group?: string, sort?: 'firstname' | 'surname' | 'updated' | 'relevance', order?: 'asc' | 'desc', offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2002>;

    /**
     * Return the user\'s activity feed.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {boolean} [app_feeds_only] Filter the feed for the mobile app. Returns only group related messages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUserIdActivityGet(user_id: string, offset?: number, limit?: number, app_feeds_only?: boolean, options?: any): AxiosPromise<InlineResponse2003>;

    /**
     * Stop following a user.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUserIdFollowDelete(user_id: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} user_id The Invotra UUID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUserIdFollowGet(user_id: string, options?: any): AxiosPromise<CommonStatusSchema>;

    /**
     * Follow a user as another user.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUserIdFollowPut(user_id: string, options?: any): AxiosPromise<void>;

    /**
     * List of who a user is following.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUserIdFollowingGet(user_id: string, offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2007>;

    /**
     * Get the user\'s information.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUserIdGet(user_id: string, options?: any): AxiosPromise<UserSchema>;

    /**
     * List a user\'s groups.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUserIdGroupsGet(user_id: string, offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2008>;

    /**
     * List the user\'s job roles.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUserIdJobRolesGet(user_id: string, offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2004>;

    /**
     * Remove a job role from a user.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {string} job_role_id The Invotra UUID of the job role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUserIdJobRolesJobRoleIdDelete(user_id: string, job_role_id: string, options?: any): AxiosPromise<void>;

    /**
     * Add a job role to a user.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {string} job_role_id The Invotra UUID of the job role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUserIdJobRolesJobRoleIdPut(user_id: string, job_role_id: string, options?: any): AxiosPromise<void>;

    /**
     * List the user\'s locations.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUserIdLocationsGet(user_id: string, offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2005>;

    /**
     * Remove a location from a user.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {string} location_id The Invotra UUID of the location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUserIdLocationsLocationIdDelete(user_id: string, location_id: string, options?: any): AxiosPromise<void>;

    /**
     * Add a location to a user.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {string} location_id The Invotra UUID of the location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUserIdLocationsLocationIdPut(user_id: string, location_id: string, options?: any): AxiosPromise<void>;

    /**
     * Update the user\'s information.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {UserSchemaUpdate} UserSchemaUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUserIdPut(user_id: string, UserSchemaUpdate: UserSchemaUpdate, options?: any): AxiosPromise<void>;

    /**
     * List a user\'s teams
     * @param {string} user_id The Invotra UUID of the user.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUserIdTeamsGet(user_id: string, offset?: number, limit?: number, options?: any): AxiosPromise<InlineResponse2006>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * Search for users. Returns list of uuids.
     * @param {string} external_id Filter by external ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGet(external_id: string, options?: any) {
        return UsersApiFp(this.configuration).usersGet(external_id, options)(this.axios, this.basePath);
    }

    /**
     * Get the current user\'s information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMeGet(options?: any) {
        return UsersApiFp(this.configuration).usersMeGet(options)(this.axios, this.basePath);
    }

    /**
     * Autocomplete names and email addresses for @-mentioning. The text parameter matches against the start of the user\'s full name (forename surname or surname forename) or email address. Full user objects are returned. The list may optionally be filtered by group to show only members of the group, to allow completing only users that can be mentioned when composing a group post. You can not filter by members of a private or secret group unless you are a member yourself. Webmasters can always be mentioned, so they are always matched even if they are not members of the group being filtered. Redacted users are never matched.
     * @summary Autocomplete names and email addresses for @-mentioning.
     * @param {string} text Text to match against the start of the user\&#39;s full name or email address.
     * @param {string} [group] UUID of the group to filter by.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMentionGet(text: string, group?: string, limit?: number, options?: any) {
        return UsersApiFp(this.configuration).usersMentionGet(text, group, limit, options)(this.axios, this.basePath);
    }

    /**
     * Returns a count of users who accessed the site on 4 or more days within a given calendar month.
     * @param {string} month Filter by calendar month. Format: YYYY-MM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMetricsAccessedGet(month: string, options?: any) {
        return UsersApiFp(this.configuration).usersMetricsAccessedGet(month, options)(this.axios, this.basePath);
    }

    /**
     * Returns the total count of active users (i.e. not blocked) profiles matching various conditions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMetricsProfilesGet(options?: any) {
        return UsersApiFp(this.configuration).usersMetricsProfilesGet(options)(this.axios, this.basePath);
    }

    /**
     * Provision a new user in Invotra.
     * @param {UserSchemaCreate} UserSchemaCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPost(UserSchemaCreate: UserSchemaCreate, options?: any) {
        return UsersApiFp(this.configuration).usersPost(UserSchemaCreate, options)(this.axios, this.basePath);
    }

    /**
     * Search for users. Returns user snippets. If there are no result, an empty array is returned.
     * @param {string} [fulltext_search] Search term. Matches on whole words.
     * @param {string} [team] The Invotra UUID of the team to filter by.
     * @param {string} [location] The Invotra UUID of the location to filter by.
     * @param {string} [group] The Invotra UUID of the group to filter by.
     * @param {'firstname' | 'surname' | 'updated' | 'relevance'} [sort] Field to sort by
     * @param {'asc' | 'desc'} [order] Sort order
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersSearchGet(fulltext_search?: string, team?: string, location?: string, group?: string, sort?: 'firstname' | 'surname' | 'updated' | 'relevance', order?: 'asc' | 'desc', offset?: number, limit?: number, options?: any) {
        return UsersApiFp(this.configuration).usersSearchGet(fulltext_search, team, location, group, sort, order, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     * Return the user\'s activity feed.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {boolean} [app_feeds_only] Filter the feed for the mobile app. Returns only group related messages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdActivityGet(user_id: string, offset?: number, limit?: number, app_feeds_only?: boolean, options?: any) {
        return UsersApiFp(this.configuration).usersUserIdActivityGet(user_id, offset, limit, app_feeds_only, options)(this.axios, this.basePath);
    }

    /**
     * Stop following a user.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdFollowDelete(user_id: string, options?: any) {
        return UsersApiFp(this.configuration).usersUserIdFollowDelete(user_id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} user_id The Invotra UUID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdFollowGet(user_id: string, options?: any) {
        return UsersApiFp(this.configuration).usersUserIdFollowGet(user_id, options)(this.axios, this.basePath);
    }

    /**
     * Follow a user as another user.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdFollowPut(user_id: string, options?: any) {
        return UsersApiFp(this.configuration).usersUserIdFollowPut(user_id, options)(this.axios, this.basePath);
    }

    /**
     * List of who a user is following.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdFollowingGet(user_id: string, offset?: number, limit?: number, options?: any) {
        return UsersApiFp(this.configuration).usersUserIdFollowingGet(user_id, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     * Get the user\'s information.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdGet(user_id: string, options?: any) {
        return UsersApiFp(this.configuration).usersUserIdGet(user_id, options)(this.axios, this.basePath);
    }

    /**
     * List a user\'s groups.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdGroupsGet(user_id: string, offset?: number, limit?: number, options?: any) {
        return UsersApiFp(this.configuration).usersUserIdGroupsGet(user_id, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     * List the user\'s job roles.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdJobRolesGet(user_id: string, offset?: number, limit?: number, options?: any) {
        return UsersApiFp(this.configuration).usersUserIdJobRolesGet(user_id, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     * Remove a job role from a user.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {string} job_role_id The Invotra UUID of the job role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdJobRolesJobRoleIdDelete(user_id: string, job_role_id: string, options?: any) {
        return UsersApiFp(this.configuration).usersUserIdJobRolesJobRoleIdDelete(user_id, job_role_id, options)(this.axios, this.basePath);
    }

    /**
     * Add a job role to a user.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {string} job_role_id The Invotra UUID of the job role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdJobRolesJobRoleIdPut(user_id: string, job_role_id: string, options?: any) {
        return UsersApiFp(this.configuration).usersUserIdJobRolesJobRoleIdPut(user_id, job_role_id, options)(this.axios, this.basePath);
    }

    /**
     * List the user\'s locations.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdLocationsGet(user_id: string, offset?: number, limit?: number, options?: any) {
        return UsersApiFp(this.configuration).usersUserIdLocationsGet(user_id, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     * Remove a location from a user.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {string} location_id The Invotra UUID of the location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdLocationsLocationIdDelete(user_id: string, location_id: string, options?: any) {
        return UsersApiFp(this.configuration).usersUserIdLocationsLocationIdDelete(user_id, location_id, options)(this.axios, this.basePath);
    }

    /**
     * Add a location to a user.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {string} location_id The Invotra UUID of the location.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdLocationsLocationIdPut(user_id: string, location_id: string, options?: any) {
        return UsersApiFp(this.configuration).usersUserIdLocationsLocationIdPut(user_id, location_id, options)(this.axios, this.basePath);
    }

    /**
     * Update the user\'s information.
     * @param {string} user_id The Invotra UUID of the user.
     * @param {UserSchemaUpdate} UserSchemaUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdPut(user_id: string, UserSchemaUpdate: UserSchemaUpdate, options?: any) {
        return UsersApiFp(this.configuration).usersUserIdPut(user_id, UserSchemaUpdate, options)(this.axios, this.basePath);
    }

    /**
     * List a user\'s teams
     * @param {string} user_id The Invotra UUID of the user.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The numbers of items to return. If the value specified is more than the maximum, the result count will be limited to the maximum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdTeamsGet(user_id: string, offset?: number, limit?: number, options?: any) {
        return UsersApiFp(this.configuration).usersUserIdTeamsGet(user_id, offset, limit, options)(this.axios, this.basePath);
    }

}
